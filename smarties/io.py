import numpy as np
import healpy as hp
from tqdm import tqdm
from smarties.hn import Spin_maps

def read_file(name_file, format_file='fits', mask=...):

    if format_file == 'fits':
        if not name_file.endswith('.fits'):
            name_file = name_file + '.fits'
        return hp.read_map(name_file)[mask]
    elif format_file == 'npy':
        if not name_file.endswith('.npy'):
            name_file = name_file + '.npy'
        return np.load(name_file)[mask]
    elif format_file == 'npz':
        if not name_file.endswith('.npz'):
            name_file = name_file + '.npz'
        return np.load(name_file) #, allow_pickle=True)
    else:
        raise ValueError("Unknown format: {}".format(format_file))



def read_h_n_file(name_file, list_spin=[2,4], format_file='fits', mask=None):
    """
    Read the $h_n$ map as generated by TOAST, 
    which filename is preferrentially given as
        filever_w14_p082_f150_A_sin_1.fits
    with:
    * filever: the version of the file
    * w14: the number of the wafer (here 14)
    * p082: the pixel number (here 082)
    * f150: the frequency band (here 150 GHz)
    * A: the polarization detector number (here A)
    * sin_1: the spin dependence and component written, here the $h_n$ component with spin 1 
    
    Only the latest part of the file actually matters, considering the $sin$ or $cos$ component of the $h_n$ map as well as its spin dependence. 

    Args:
        name_file (str): the version of the file, given so that `hp.read_map(name_file + '_sin_1.fits')` can be used to read the file (with `sin_1` being the sin or cos component of the $h_n$ maps and the spin dependence)
        list_spin (list[int]): list of the spin to read

    Returns:
        h_n (dict): the $h_n$ maps stored in a dictionary of spins and ordered as [n_det, n_pix], with n_det=1, except for spin=0 which dimension is [1,1] and only contains the float 1.

    Note:
    """
    assert np.unique(list_spin).size == np.array(list_spin).size, 'The list of spins must be unique'
    assert (np.array(list_spin) > 0).all(), 'The spins provided must be positive, their negative counterpart will be computed from the components read'

    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)


    h_n_spin_dict = Spin_maps()
    
    for i,spin in enumerate(list_spin):
        sin_spin_h_n = read_file(name_file + '_sin_{}'.format(spin), format_file=format_file, mask=bool_mask)
        cos_spin_h_n = read_file(name_file + '_cos_{}'.format(spin), format_file=format_file, mask=bool_mask)
        h_n_spin_dict[spin] = np.expand_dims(cos_spin_h_n + 1j * sin_spin_h_n, 0)
        h_n_spin_dict[-spin] = np.expand_dims(cos_spin_h_n - 1j * sin_spin_h_n, 0)
        cos_spin_h_n = None
        sin_spin_h_n = None

    h_n_spin_dict[0] = np.expand_dims([1.],0)
    return h_n_spin_dict

def read_detectors_h_n_maps(list_name_files, list_spin, format_file='fits', list_weights=None, mask=None):
    """
    Read the $h_n$ maps for all the detectors given in list_name_files

    Args:
        list_name_files (list[str]): list of the name of the files to read
        list_spin (list[int]): list of the spin to read
        list_weights (list[float]): list of the weights per detector, to apply to the $h_n$ so that the total $h_n$ maps are weighted by the total nhits of the detectors, if None, the nhits is assumed to be the same for all detectors and a weight of 1/sqrt(n_det) is applied
    
    Returns:
        h_n_spin_dict (Spin_maps): the $h_n$ maps stored in a Spin_maps object with the keys being the spins and the elements being ordered as [n_det, n_pix], with n_det the number of detectors and n_pix the number of pixels in the $h_n$ maps, except for spin=0 which dimension is [n_det,1] and only contains the float 1.

    """
    
    n_det = len(list_name_files)

    if list_weights is None:
        list_weights = np.ones(n_det, dtype=float) / n_det
    
    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)

    h_n_spin_dict = Spin_maps.from_dictionary(read_h_n_file(list_name_files[0], list_spin=list_spin, mask=bool_mask, format_file=format_file))
    for spin in h_n_spin_dict.spins:
        h_n_spin_dict[spin] *= list_weights[0]

    for i, path_h_n_maps in enumerate(list_name_files[1:]):
        h_n_spin_dict_to_add = Spin_maps.from_dictionary(read_h_n_file(path_h_n_maps, list_spin=list_spin, mask=bool_mask, format_file=format_file))
        for spin in h_n_spin_dict.spins:
            h_n_spin_dict[spin] = np.vstack((h_n_spin_dict[spin],h_n_spin_dict_to_add[spin]*list_weights[i+1]))
    return h_n_spin_dict



def read_detectors_h_n_file_npz(list_name_files, list_spin=[2,4], list_prefix=['A_', 'B_'], list_weights=None, mask=None, format_file='npz'):
    """
    Read the $h_n$ map as generated by TOAST, 
    which filename is preferrentially given as
        filever_w14_p082_f150_A_sin_1.fits
    with:
    * filever: the version of the file
    * w14: the number of the wafer (here 14)
    * p082: the pixel number (here 082)
    * f150: the frequency band (here 150 GHz)
    * A: the polarization detector number (here A)
    * sin_1: the spin dependence and component written, here the $h_n$ component with spin 1 
    
    Only the latest part of the file actually matters, considering the $sin$ or $cos$ component of the $h_n$ map as well as its spin dependence. 

    Args:
        name_file (str): the version of the file, given so that `hp.read_map(name_file + '_sin_1.fits')` can be used to read the file (with `sin_1` being the sin or cos component of the $h_n$ maps and the spin dependence)
        list_spin (list[int]): list of the spin to read

    Returns:
        h_n (dict): the $h_n$ maps stored in a dictionary of spins and ordered as [n_det, n_pix], with n_det=1, except for spin=0 which dimension is [1,1] and only contains the float 1.

    Note:
    """
    assert np.unique(list_spin).size == np.array(list_spin).size, 'The list of spins must be unique'
    assert (np.array(list_spin) > 0).all(), 'The spins provided must be positive, their negative counterpart will be computed from the components read'

    n_det = len(list_name_files) * len(list_prefix)

    if list_weights is None:
        list_weights = np.ones(n_det, dtype=float) / n_det
    
    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)

    total_list_spin = list_spin + [-spin for spin in list_spin]

    h_n_dictionary = {spin: [] for spin in total_list_spin}  # Initialize dictionary for spins
    for j, name_file in enumerate(tqdm(list_name_files)):
        spin_h_n = read_file(name_file, format_file=format_file)

        for spin in list_spin:
            for prefix in list_prefix:
                
                sin_spin_h_n = spin_h_n[prefix+'sin_{}'.format(spin)][bool_mask]
                cos_spin_h_n = spin_h_n[prefix+'cos_{}'.format(spin)][bool_mask]
                h_n_dictionary[spin].append((cos_spin_h_n + 1j * sin_spin_h_n)[np.newaxis,...] * list_weights[j])
                h_n_dictionary[-spin].append((cos_spin_h_n - 1j * sin_spin_h_n)[np.newaxis,...] * list_weights[j])
        spin_h_n = None

    print("Finalizing h_n dictionary...", flush=True)
    for spin in total_list_spin:
        h_n_dictionary[spin] = np.vstack(h_n_dictionary[spin])

    h_n_dictionary[0] = list_weights[..., np.newaxis]
    h_n_spin_dict = Spin_maps.from_dictionary(h_n_dictionary)
    return h_n_spin_dict
