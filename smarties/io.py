# This file is part of SMARTIES.
# Copyright (C) 2024 CNRS / SciPol developers
#
# SMARTIES is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SMARTIES is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SMARTIES. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import healpy as hp
from tqdm import tqdm
from smarties.hn import Spin_maps

def read_file(name_file:str, format_file:str='fits', mask:str=...):
    """
    Read the $h_n$ maps as provided either in FITS, NPY or NPZ
    format, and eventually mask them. 

    Parameters
    ----------
    name_file: str
        Path to the $h_n$ file to be read. If the path provided does
        not contain the fomat suffix, in '.fits', '.npy' or '.npz',
        the suffix corresponding to the format indicated in format_file
        will be concatenated. 
    format_file: str
        String indicated the format of the file to be read, must be 
        either 'fits', 'npy' or 'npz' otherwise a ValueError is raised 
    mask: array[bool] | Ellipsis
        Optional, boolean array corresponding to the selected pixels in 
        the array to retain after loading the file. By default, return 
        all pixels. Note that this option is not active for 'npz' format
        files. 

    Returns
    -------
        Array containing the $h_n$ map read, from which only the relevant
        pixels are possibly retained. 
    """

    if format_file == 'fits':
        if not name_file.endswith('.fits'):
            name_file = name_file + '.fits'
        return hp.read_map(name_file)[mask]
    elif format_file == 'npy':
        if not name_file.endswith('.npy'):
            name_file = name_file + '.npy'
        return np.load(name_file)[mask]
    elif format_file == 'npz':
        if not name_file.endswith('.npz'):
            name_file = name_file + '.npz'
        return np.load(name_file) #, allow_pickle=True)
    else:
        raise ValueError("Unknown format: {}".format(format_file))



def read_h_n_file(name_file, list_spin=[2,4], format_file='fits', mask=None):
    """
    Read the $h_n$ map as generated by TOAST, 
    which filename is preferrentially given as
        filever_w14_p082_f150_A_sin_1.fits
    with:
    * filever: the version of the file
    * w14: the number of the wafer (here 14)
    * p082: the pixel number (here 082)
    * f150: the frequency band (here 150 GHz)
    * A: the polarization detector number (here A)
    * sin_1: the spin dependence and component written, here the $h_n$ component with spin 1 
    
    Only the latest part of the file actually matters, considering the $sin$ or $cos$ component of the $h_n$ map as well as its spin dependence. 

    Parameters
    ----------
    name_file: str
        The version of the file, given so that `hp.read_map(name_file + '_sin_1.fits')` can be used to read the file (with `sin_1` being the sin or cos component of the $h_n$ maps and the spin dependence) list_spin (list[int]): list of the spin to read

    Returns
    -------
    h_n: dict
        The $h_n$ maps stored in a dictionary of spins and ordered as [n_det, n_pix], with n_det=1, except for spin=0 which dimension is [1,1] and only contains the float 1.

    Note:
    """
    assert np.unique(list_spin).size == np.array(list_spin).size, 'The list of spins must be unique'
    assert (np.array(list_spin) > 0).all(), 'The spins provided must be positive, their negative counterpart will be computed from the components read'

    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)


    h_n_spin_dict = Spin_maps()
    
    for i,spin in enumerate(list_spin):
        sin_spin_h_n = read_file(name_file + '_sin_{}'.format(spin), format_file=format_file, mask=bool_mask)
        cos_spin_h_n = read_file(name_file + '_cos_{}'.format(spin), format_file=format_file, mask=bool_mask)
        h_n_spin_dict[spin] = np.expand_dims(cos_spin_h_n + 1j * sin_spin_h_n, 0)
        h_n_spin_dict[-spin] = np.expand_dims(cos_spin_h_n - 1j * sin_spin_h_n, 0)
        cos_spin_h_n = None
        sin_spin_h_n = None

    h_n_spin_dict[0] = np.expand_dims([1.],0)
    return h_n_spin_dict

def read_detectors_h_n_maps(list_name_files, list_spin, format_file='fits', list_weights=None, mask=None):
    """
    Read the $h_n$ maps for all the detectors given in list_name_files

    Parameters
    ----------
    list_name_files: list[str]
        List of the name of the files to read
        list_spin (list[int]): list of the spin to read
        list_weights (list[float]): list of the weights per detector, to apply to the $h_n$ so that the total $h_n$ maps are weighted by the total nhits of the detectors, if None, the nhits is assumed to be the same for all detectors and a weight of 1/sqrt(n_det) is applied
    
    Returns
    -------
    h_n_spin_dict: Spin_maps
        The $h_n$ maps stored in a Spin_maps object with the keys being the spins and the elements being ordered as [n_det, n_pix], with n_det the number of detectors and n_pix the number of pixels in the $h_n$ maps, except for spin=0 which dimension is [n_det,1] and only contains the float 1.

    """
    
    n_det = len(list_name_files)

    if list_weights is None:
        list_weights = np.ones(n_det, dtype=float) / n_det
    
    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)

    h_n_spin_dict = Spin_maps.from_dictionary(read_h_n_file(list_name_files[0], list_spin=list_spin, mask=bool_mask, format_file=format_file))
    for spin in h_n_spin_dict.spins:
        h_n_spin_dict[spin] *= list_weights[0]

    for i, path_h_n_maps in enumerate(list_name_files[1:]):
        h_n_spin_dict_to_add = Spin_maps.from_dictionary(read_h_n_file(path_h_n_maps, list_spin=list_spin, mask=bool_mask, format_file=format_file))
        for spin in h_n_spin_dict.spins:
            h_n_spin_dict[spin] = np.vstack((h_n_spin_dict[spin],h_n_spin_dict_to_add[spin]*list_weights[i+1]))
    return h_n_spin_dict



def read_detectors_h_n_file_npz(
        list_name_files, 
        list_spin=[2,4], 
        list_prefix=['A_', 'B_'], 
        list_weights=None, 
        mask=None, 
        format_file='npz',
        new_weighting_bool=False
    ):
    """
    Read the $h_n$ map as generated by TOAST, 
    which filename is preferrentially given as
        filever_w14_p082_f150_A_sin_1.fits
    with:
    * filever: the version of the file
    * w14: the number of the wafer (here 14)
    * p082: the pixel number (here 082)
    * f150: the frequency band (here 150 GHz)
    * A: the polarization detector number (here A)
    * sin_1: the spin dependence and component written, here the $h_n$ component with spin 1 
    
    Only the latest part of the file actually matters, considering the $sin$ or $cos$ component of the $h_n$ map as well as its spin dependence. 

    Parameters
    ----------
    name_file: str
        The version of the file, given so that `hp.read_map(name_file + '_sin_1.fits')` can be used to read the file (with `sin_1` being the sin or cos component of the $h_n$ maps and the spin dependence)
        list_spin (list[int]): list of the spin to read

    Returns
    -------
    h_n: Spin_maps
        The $h_n$ maps stored in a dictionary of spins and ordered as [n_det, n_pix], with n_det=1, except for spin=0 which dimension is [1,1] and only contains the float 1.

    Note:
    """
    assert np.unique(list_spin).size == np.array(list_spin).size, 'The list of spins must be unique'
    assert (np.array(list_spin) > 0).all(), 'The spins provided must be positive, their negative counterpart will be computed from the components read'

    n_det = len(list_name_files) * len(list_prefix)

    if list_weights is None:
        list_weights = np.ones(n_det, dtype=float) / n_det
    
    if mask is None:
        bool_mask = ...
    elif mask is not None:
        bool_mask = np.array(mask, dtype=bool)

    total_list_spin = list_spin + [-spin for spin in list_spin]

    h_n_dictionary = {spin: [] for spin in total_list_spin}  # Initialize dictionary for spins
    for j, name_file in enumerate(tqdm(list_name_files)):
        spin_h_n = read_file(name_file, format_file=format_file)

        for spin in list_spin:
            for prefix in list_prefix:
                
                sin_spin_h_n = spin_h_n[prefix+'sin_{}'.format(spin)][bool_mask]
                cos_spin_h_n = spin_h_n[prefix+'cos_{}'.format(spin)][bool_mask]
                h_n_dictionary[spin].append((cos_spin_h_n + 1j * sin_spin_h_n)[np.newaxis,...] * list_weights[j])
                h_n_dictionary[-spin].append((cos_spin_h_n - 1j * sin_spin_h_n)[np.newaxis,...] * list_weights[j])
        spin_h_n = None

    print("Finalizing h_n dictionary...", flush=True)
    for spin in total_list_spin:
        h_n_dictionary[spin] = np.vstack(h_n_dictionary[spin])

    h_n_dictionary[0] = list_weights[..., np.newaxis]

    if new_weighting_bool:
        print("Applying new weighting to h_n dictionary...", flush=True)
        new_weighting_array = np.ones(h_n_dictionary[list_spin[0]].shape, dtype=bool)

        for spin in total_list_spin:
            if spin != 0:
                new_weighting_array *= np.abs(h_n_dictionary[spin]) > 0
        pixel_map_weighting_array = np.sum(new_weighting_array, axis=0)
        
        for spin in total_list_spin:
            if spin != 0:
                h_n_dictionary[spin] = h_n_dictionary[spin] * n_det / pixel_map_weighting_array

    h_n_spin_dict = Spin_maps.from_dictionary(h_n_dictionary)
    return h_n_spin_dict
