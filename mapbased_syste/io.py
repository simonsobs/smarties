import numpy as np
import healpy as hp
from mapbased_syste.hn import Spin_maps

def read_h_n_file(name_file, list_spin=[2,4]):
    """
    Read the $h_n$ map as generated by TOAST, 
    which filename is preferrentially given as
        filever_w14_p082_f150_A_sin_1.fits
    with:
    * filever: the version of the file
    * w14: the number of the wafer (here 14)
    * p082: the pixel number (here 082)
    * f150: the frequency band (here 150 GHz)
    * A: the polarization detector number (here A)
    * sin_1: the spin dependence and component written, here the $h_n$ component with spin 1 
    
    Only the latest part of the file actually matters, considering the $sin$ or $cos$ component of the $h_n$ map as well as its spin dependence. 

    Args:
        name_file (str): the version of the file, given so that `hp.read_map(name_file + '_sin_1.fits')` can be used to read the file (with `sin_1` being the sin or cos component of the $h_n$ maps and the spin dependence)
        list_spin (list[int]): list of the spin to read

    Returns:
        h_n (dict): the $h_n$ maps stored in a dictionary of spins and ordered as [n_det, n_pix], with n_det=1, except for spin=0 which dimension is [1,1] and only contains the float 1.

    Note:
    """
    assert np.unique(list_spin).size == np.array(list_spin).size, 'The list of spins must be unique'
    assert (np.array(list_spin) > 0).all(), 'The spins provided must be positive, their negative counterpart will be computed from the components read'

    h_n_spin_dict = dict()
    
    for i,spin in enumerate(list_spin):
        sin_spin_h_n = hp.read_map(name_file + '_sin_{}.fits'.format(spin))
        cos_spin_h_n = hp.read_map(name_file + '_cos_{}.fits'.format(spin))
        h_n_spin_dict[spin] = np.expand_dims(cos_spin_h_n + 1j * sin_spin_h_n, 0)
        h_n_spin_dict[-spin] = np.expand_dims(cos_spin_h_n - 1j * sin_spin_h_n, 0)

    h_n_spin_dict[0] = np.expand_dims([1.],0)
    return h_n_spin_dict

def read_detectors_h_n_maps(list_name_files, list_spin, list_weights=None):
    """
    Read the $h_n$ maps for all the detectors given in list_name_files

    Args:
        list_name_files (list[str]): list of the name of the files to read
        list_spin (list[int]): list of the spin to read
        list_weights (list[float]): list of the weights per detector, to apply to the $h_n$ so that the total $h_n$ maps are weighted by the total nhits of the detectors, if None, the nhits is assumed to be the same for all detectors and a weight of 1/sqrt(n_det) is applied
    
    Returns:
        h_n_spin_dict (Spin_maps): the $h_n$ maps stored in a Spin_maps object with the keys being the spins and the elements being ordered as [n_det, n_pix], with n_det the number of detectors and n_pix the number of pixels in the $h_n$ maps, except for spin=0 which dimension is [n_det,1] and only contains the float 1.

    """
    
    n_det = len(list_name_files)

    if list_weights is None:
        list_weights = np.ones(n_det, dtype=float) / n_det

    h_n_spin_dict = Spin_maps.from_dictionary(read_h_n_file(list_name_files[0], list_spin=list_spin))
    for spin in h_n_spin_dict.spins:
        h_n_spin_dict[spin] *= list_weights[0]

    for i, path_h_n_maps in enumerate(list_name_files[1:]):
        h_n_spin_dict_to_add = Spin_maps.from_dictionary(read_h_n_file(path_h_n_maps, list_spin=list_spin))
        for spin in h_n_spin_dict.spins:
            h_n_spin_dict[spin] = np.vstack((h_n_spin_dict[spin],h_n_spin_dict_to_add[spin]*list_weights[i+1]))
    return h_n_spin_dict
